{
    "collab_server" : "",
    "contents" : "#' Simulate a Plant Ecosystem\n#'\n#' Setup.plants: makes a list of objects needed to run the plant ecosystem function.\n#'\n#' @param reproduce A vector of length n storing reproduction probabilities for n plant species. Must be values between 0 and 1.\n#' @param survive A vector of length n storing survival probabilities for n plant species. Must be values between 0 and 1.\n#' @param compete.matrix An nxn matrix storing the probability the plant in row i will outcompete the plant in column j, given n plant species. Must be values between 0 and 1.\n#' @param names A vector of length n storing the names of the n plants in the ecosystem. If no names are given, they will be automatically assigned.\n#' @return A list containing all survival, reproduction, and survival values for the user's plant ecosystem.\n#'\n#' @export\nsetup.plants <- function(reproduce, survive, compete.matrix, names = NULL){\n  if(is.null(names) == TRUE){\n    names <- letters[1:length(reproduce)]\n  }\n  if(length(names) != length(reproduce)){\n    stop(\"Each plant must have a name.\")\n  }\n  if(length(reproduce) != length(survive)){\n    stop(\"Reproduction and survival parameters needed for each species.\")\n  }\n  if(nrow(compete.matrix) != length(reproduce) | ncol(compete.matrix) != length(reproduce)){\n    stop(\"Competition matrix must have competition parameters for each pairwise combination of species.\")\n  }\n  if(any(reproduce > 1)| any(reproduce < 0) | any(survive > 1) | any(survive < 0) | any(compete.matrix) > 1 | any(compete.matrix < 0)){\n    stop(\"Reproduction, survival and competition probabilities must be values between zero and one!\")\n  }\n  reproduce <- setNames(reproduce, names)\n  survive <- setNames(survive, names)\n  rownames(compete.matrix) <- names\n  colnames(compete.matrix) <- names\n\n  return(list(reproduce = reproduce, survive = survive, compete.matrix = compete.matrix, names = names))\n}\n\n#survival function: determines if plants live or die:\n\nsurvival <- function(cell, setup.plants){\n  if(is.na(cell) == TRUE){\n    cell <- NA\n  } else if(cell == \"\"){\n    cell <- \"\"\n  } else if(is.na(setup.plants$survive[cell]) == TRUE){\n    stop(\"You just discovered a new species of plant! Whatever is in this cell shouldn't exist... try again.\")\n  } else {\n    random.draw <- runif(1)\n    if(random.draw <= setup.plants$survive[cell]){\n      cell <- cell\n    } else if(random.draw > setup.plants$survive[cell]){\n      cell <- \"\"\n    }\n  }\n  return(cell)\n}\n\n#Seed.plants: fills the terrain with plants...\n#AS MANY AS YOU SPECIFY, NO MORE, NO LESS.\n#NONE WILL FALL ON WATER AND DIE; 100% SEEDED ON LAND.\n#ALL SEEDED RANDOMLY, NO BIAS TOWARDS THOSE SEEDED FIRST OR LAST\n\nseed.plants <- function(terrain, setup.plants, number.plants){\n  if(length(number.plants) != length(setup.plants$names)){\n    stop(\"There must be an initial population size given for every plant species in the 'number of plants per species' vector!\")\n  }\n  all.terrain.locations <- seq(1, nrow(terrain)^2, 1)\n  #Vector of all possible cells in the terrain matrix, from which locations for plants can be drawn\n  water.locations <- which(is.na(terrain) == TRUE)\n  #Vector of all the cells in the initial matrix that contain water, and therefore are NOT potential locations for plants.\n  terrain.locations.minus.water <- all.terrain.locations[-water.locations]\n  #Vector of all cells in matrix WITHOUT water, and therefore potential locations for plants\n  total.number.plants <- sum(number.plants)\n  #Adds up the initial population values for all the plant species to give total population (plants of any species)\n  if(total.number.plants > length(terrain.locations.minus.water)){\n    stop(\"There are more plants to seed than there are locations on the terrain to put plants!\", \"\\n\",\n         \"  You currently have \", total.number.plants, \" plants, and only \", length(terrain.locations.minus.water), \" places to put them!\")\n  }\n  #Checks to see if there are too many plants to fit on your terrain\n  locations.for.plants.to.go <- sample(terrain.locations.minus.water, total.number.plants)\n  #Draws a random sample of locations in which to put the total number of plants you said you wanted to seed\n\n  number.plants <- setNames(number.plants, setup.plants$names)\n  #Takes the vector containing number of plants of each species to seed, and names them appropriately\n  plants.to.add <- character(0)\n  for(i in 1:length(number.plants)){\n    plants.to.add <- c(plants.to.add, rep(names(number.plants[i]), number.plants[i]))\n  }\n  #Creates a vector of plants, with each plant species repeated the number of times specified by the user\n  random.ordering.for.plants <- sample(1:length(plants.to.add), length(plants.to.add))\n  #creates a vector that will become the indices for the shuffled plants.to.add vector (to eliminate all possible bias in seeding)\n  shuffled.plants.to.add <- character(0)\n  for(i in 1:length(plants.to.add)){\n    shuffled.plants.to.add[i] <- plants.to.add[random.ordering.for.plants[i]]\n  }\n  #SHUFFLES the vector of plants to add randomly to the terrain because I hate bias and want things seeded randomly.\n  plant.matrix <- matrix(nrow = nrow(terrain), ncol = ncol(terrain), \"\")\n  #Creates the final plant matrix, into which plants and water will be seeded\n  plant.matrix[water.locations] <- NA\n  #Sets all water locations to NA\n  plant.matrix[locations.for.plants.to.go] <- shuffled.plants.to.add\n  #Puts the plants into the matrix, and none should fall on top of each other or on water!\n  return(plant.matrix)\n}\n\n\n#' run.plant.ecosystem: makes an array showing changes in the plant ecosystem (location and abundance) through time\n#'\n#' @param terrain A matrix generated using the terrain function into which plants can be placed\n#' @param setup.plants A list generated from the setup.plants function using the survival, reproduction, and competition probabilities for each plant wanted in the ecosystem\n#' @param numb.plants.per.sp A vector of length n storing the values for the initial population size desired for each of n plant species.\n#' @param timesteps A numeric value representing the number of timesteps over which the user wishes to simulate their ecosystem.\n\n#' @export\nrun.plant.ecosystem <- function(terrain, setup.plants, numb.plants.per.sp, timesteps){\n  plant.array <- array(dim = c(nrow(terrain), ncol(terrain), timesteps + 1))\n  #Creates plant array to put stuff into.\n  plant.array[,,1] <- seed.plants(terrain, setup.plants, numb.plants.per.sp)\n  for(i in 1:(timesteps)){\n    plant.array[,,(i + 1)] <- plant.timestep(plant.array[,,i], setup.plants)\n  }\n  return(plant.array)\n}\n\n#Drawing a random location for the F1 generation offspring to be placed into:\n\noffspring.location <- function(F0.row, F0.col, plant.matrix){\n  potential.F1.locations <- as.matrix(expand.grid(F0.row + c(0, -1, 1), F0.col + c(0, -1, 1)))\n  #Matrix storing all possible locations for plant offspring, INCLUDING the location of the parent\n  potential.F1.locations.minus.center <- potential.F1.locations\n  #Matrix storing potential locations for plant offspring MINUS the location of the parent\n  for(k in 1:nrow(potential.F1.locations)){\n    if(potential.F1.locations[k, 1] == F0.row & potential.F1.locations[k, 2] == F0.col){\n      potential.F1.locations.minus.center <- potential.F1.locations[-k,]\n    }\n    #Loop that takes the list of all possible locations and removes the center point (the location of the parent plant)\n\n    potential.F1.row <- potential.F1.locations.minus.center[,1]\n    potential.F1.col <- potential.F1.locations.minus.center[,2]\n    #Vector from the possible offspring location matrix storing the indices of potential rows and columns for offspring\n\n    rows.to.remove <- c(which(potential.F1.row > nrow(plant.matrix)), which(potential.F1.row < 1))\n    col.to.remove <- c(which(potential.F1.col > ncol(plant.matrix)), which(potential.F1.col < 1))\n    #Vectors determining which row and column locations are off the grid (terrain), and need to be removed\n\n    if(length(rows.to.remove) > 0 | length(col.to.remove > 0)){\n      potential.F1.row <- potential.F1.row[-c(rows.to.remove, col.to.remove)]\n      potential.F1.col <- potential.F1.col[-c(rows.to.remove, col.to.remove)]\n    }\n    #corrected vectors storing potential row/col locations for offspring, all invalid locations removed\n\n    potential.location.index <- seq(from = 1, to = length(potential.F1.row), by = 1)\n    offspring.location.index <- sample(potential.location.index, 1)\n    #draws a random sample from the vector of potential F1 locations\n\n    offspring.location <- c(potential.F1.row[offspring.location.index], potential.F1.col[offspring.location.index])\n    return(offspring.location)\n  }\n}\n\n#Revised plant.timestep function including reproduction:\n\nplant.timestep <- function(plant.matrix, setup.plants){\n  new.plant.matrix <- plant.matrix\n  for(i in 1:nrow(plant.matrix)){\n    for(j in 1:ncol(plant.matrix)){\n      new.plant.matrix[i, j] <- survival(plant.matrix[i,j], setup.plants)\n    }\n  }\n  repro.plant.matrix <- reproduction(new.plant.matrix, setup.plants)\n  return(repro.plant.matrix)\n}\n\n#Competition function:\n\ncompete <- function(parent.cell, potential.offspring.cell, setup.plants){\n  winner <- sample(c(parent.cell, potential.offspring.cell), 1, prob = c(setup.plants$compete.matrix[parent.cell, potential.offspring.cell], (1 - setup.plants$compete.matrix[parent.cell, potential.offspring.cell])))\n  return(winner)\n}\n\n#Revised reproduction function including competition element:\n\nreproduction <- function(plant.matrix, setup.plants){\n  repro.plant.matrix <- plant.matrix\n  #creates a new matrix for the \"next generation\" to be seeded into without messing up the original matrix I'm drawing from\n  for(i in 1:nrow(plant.matrix)){\n    for(j in 1:ncol(plant.matrix)){\n      cell <- plant.matrix[i, j]\n      if(is.na(cell) == TRUE){\n        cell <- NA\n      } else if(cell == \"\"){\n        cell <- \"\"\n      } else if(is.na(setup.plants$reproduce[cell]) == TRUE){\n        stop(\"You just discovered a new species of plant! Whatever is in this cell shouldn't exist... try again.\")\n      } else if(is.na(setup.plants$reproduce[cell]) == FALSE){\n        if(runif(1) <= setup.plants$reproduce[cell]){\n          offspring.location <- offspring.location(i, j, plant.matrix)\n          if(is.na(plant.matrix[offspring.location[1], offspring.location[2]] == TRUE)){\n            repro.plant.matrix[offspring.location[1], offspring.location[2]] <- NA\n          } else if(repro.plant.matrix[offspring.location[1], offspring.location[2]] == \"\"){\n            repro.plant.matrix[offspring.location[1], offspring.location[2]] <- cell\n          } else {\n            repro.plant.matrix[offspring.location[1], offspring.location[2]] <- compete(cell, repro.plant.matrix[offspring.location[1], offspring.location[2]], setup.plants)\n          }\n        }\n      }\n    }\n  }\n  return(repro.plant.matrix)\n}\n",
    "created" : 1489790229806.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3425159127",
    "id" : "FC598CFE",
    "lastKnownWriteTime" : 1489790608,
    "last_content_update" : 1489790608997,
    "path" : "~/GitHub/blah/R/plantsFINALforPackage.R",
    "project_path" : "R/plantsFINALforPackage.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}